///
/// Copyright (C) 2016, Dependable Systems Laboratory, EPFL
/// Copyright (C) 2015-2016, Cyberhaven
/// All rights reserved.
///
/// Licensed under the Cyberhaven Research License Agreement.
///

#include <s2e/ConfigFile.h>
#include <s2e/Plugins/VulnerabilityAnalysis/Recipe/Recipe.h>
#include <s2e/S2E.h>
#include <s2e/Utils.h>

#include <klee/util/ExprUtil.h>

#include "ExploitGenerator.h"

using namespace klee;

namespace s2e {
namespace plugins {

S2E_DEFINE_PLUGIN(ExploitGenerator, "ExploitGenerator S2E plugin", "", "POVGenerator", "DecreeMonitor");

void ExploitGenerator::initialize() {
    m_monitor = s2e()->getPlugin<DecreeMonitor>();
    m_povGenerator = s2e()->getPlugin<POVGenerator>();
    m_process = s2e()->getPlugin<ProcessExecutionDetector>();

    m_recipe = s2e()->getPlugin<recipe::Recipe>();
    if (m_recipe) {
        m_recipe->onPovReady.connect(sigc::bind(sigc::mem_fun(*this, &ExploitGenerator::onPovReadyHandler), false));
    }

    if (!m_recipe) {
        getWarningsStream() << "No sources of vulnerabilities enabled\n";
        exit(-1);
    }

    m_monitor->onSegFault.connect(sigc::mem_fun(*this, &ExploitGenerator::onSegFault));

    ConfigFile *cfg = s2e()->getConfig();
    m_maxPovCount = cfg->getInt(getConfigKey() + ".maxPovCount", 5);
    m_maxCrashCount = cfg->getInt(getConfigKey() + ".maxCrashCount", 5);
    m_crashCount = 0;
}

void ExploitGenerator::onPovReadyHandler(S2EExecutionState *state, const PovOptions &opt, const std::string &recipeName,
                                         bool isCrash) {
    getInfoStream(state) << "Generating PoV type " << opt.m_type << " at " << hexval(opt.m_faultAddress)
                         << " from recipe '" << recipeName << "'\n";

    std::string xmlPov, cPov;
    m_povGenerator->generatePoV(state, opt, xmlPov, cPov);
    if (!xmlPov.length() && !cPov.length()) {
        getWarningsStream(state) << "Failed to generate PoV\n";
        return;
    }

    UniquePovKey uniquePovKey = std::make_tuple(opt.m_faultAddress, opt.m_type, recipeName);
    if (m_uniquePovMap[uniquePovKey] >= m_maxPovCount) {
        getDebugStream(state) << "PoV limit reached\n";
        return;
    }
    m_uniquePovMap[uniquePovKey]++;

    std::string prefix;
    if (recipeName.length()) {
        std::stringstream povFilenameSS;
        povFilenameSS << "recipe-" << recipeName;
        prefix = povFilenameSS.str();
    } else if (isCrash) {
        prefix = "crash";
    }

    std::string xmlFilename, cFilename;
    if (xmlPov.length()) {
        xmlFilename = m_povGenerator->writeToFile(state, opt, prefix, "xml", xmlPov);
    }
    if (cPov.length()) {
        cFilename = m_povGenerator->writeToFile(state, opt, prefix, "c", cPov);
    }
    onPovReady.emit(state, opt, recipeName, xmlFilename, cFilename, isCrash ? CRASH : POV);
}

void ExploitGenerator::onSegFault(S2EExecutionState *state, uint64_t pid, uint64_t pc) {
    if (!m_process->isTracked(state, pid)) {
        std::stringstream ss;
        m_monitor->dumpUserspaceMemory(state, ss);
        getWarningsStream(state) << ss.str();

        state->disassemble(getWarningsStream(state) << "\n", pc, 64);

        s2e_assert(state, false, "Untracked pid=" << hexval(pid) << " segfaulted");
    }

    // TODO: might not be needed once we can figure out the real instruction of the crash
    if (m_crashCount > m_maxCrashCount) {
        getDebugStream(state) << "Reached max crash count limit\n";
        return;
    }

    ++m_crashCount;

    // XXX: it's more useful to report the address of the last instructions
    PovOptions opts;
    opts.m_faultAddress = pc;
    onPovReadyHandler(state, opts, "", true);
}

} // namespace plugins
} // namespace s2e
