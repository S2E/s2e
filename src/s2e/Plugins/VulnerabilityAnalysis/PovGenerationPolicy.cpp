///
/// Copyright (C) 2016, Dependable Systems Laboratory, EPFL
/// Copyright (C) 2015-2016, Cyberhaven
/// All rights reserved.
///
/// Licensed under the Cyberhaven Research License Agreement.
///

#include <s2e/ConfigFile.h>
#include <s2e/Plugins/VulnerabilityAnalysis/Recipe/Recipe.h>
#include <s2e/S2E.h>
#include <s2e/Utils.h>

#include <klee/util/ExprUtil.h>

#include "PovGenerationPolicy.h"

using namespace klee;

namespace s2e {
namespace plugins {

S2E_DEFINE_PLUGIN(PovGenerationPolicy, "PovGenerationPolicy S2E plugin", "", "Recipe", "ProcessExecutionDetector",
                  "PovGenerator");

void PovGenerationPolicy::initialize() {

    // Getting plugin configuration
    ConfigFile *cfg = s2e()->getConfig();
    m_maxPovCount = cfg->getInt(getConfigKey() + ".maxPovCount", 5);
    m_maxCrashCount = cfg->getInt(getConfigKey() + ".maxCrashCount", 5);
    m_crashCount = 0;

    // Detecting vulnerability sources
    m_process = s2e()->getPlugin<ProcessExecutionDetector>();
    m_recipe = s2e()->getPlugin<recipe::Recipe>();
    m_recipe->onPovReady.connect(sigc::bind(sigc::mem_fun(*this, &PovGenerationPolicy::onPovReadyHandler), false));

    s2e()->getCorePlugin()->onSymbolicAddress.connect_front(
        sigc::mem_fun(*this, &PovGenerationPolicy::onSymbolicAddress));

    // Detecting platform
    m_decreeMonitor = s2e()->getPlugin<DecreeMonitor>();
    m_linuxMonitor = s2e()->getPlugin<LinuxMonitor>();
    m_windowsCrashMonitor = s2e()->getPlugin<WindowsCrashMonitor>();

    if (m_decreeMonitor) {
        m_decreeMonitor->onSegFault.connect(sigc::mem_fun(*this, &PovGenerationPolicy::onSegFault));
    } else if (m_linuxMonitor) {
        m_linuxMonitor->onSegFault.connect(sigc::mem_fun(*this, &PovGenerationPolicy::onSegFault));
        // TODO:
    }

    m_povGenerator = static_cast<pov::PovGenerator *>(s2e()->getPlugin("PovGenerator"));
}

// This will kill any states that fork because of target symbolic pc provided that there was
// already a PoV generated for at the source instruction pc.
void PovGenerationPolicy::onSymbolicAddress(S2EExecutionState *state, ref<Expr> virtualAddress,
                                            uint64_t concreteAddress, bool &concretize,
                                            CorePlugin::symbolicAddressReason reason) {
    if (!m_process->isTrackedPc(state, state->regs()->getPc(), true)) {
        return;
    }

    if (reason != CorePlugin::symbolicAddressReason::PC) {
        return;
    }

    for (const auto &it : m_uniquePovMap) {
        auto pc = std::get<0>(it.first);
        if (state->regs()->getPc() == pc) {
            s2e()->getExecutor()->terminateStateEarly(*state,
                                                      "Killing state because that PC has already generated a PoV");
        }
    }
}

void PovGenerationPolicy::onPovReadyHandler(S2EExecutionState *state, const PovOptions &opt,
                                            const std::string &recipeName, bool isCrash) {
    getInfoStream(state) << "Generating PoV type " << opt.m_type << " at " << hexval(opt.m_faultAddress)
                         << " from recipe '" << recipeName << "'\n";

    UniquePovKey uniquePovKey = std::make_tuple(opt.m_faultAddress, opt.m_type, recipeName);
    if (m_uniquePovMap[uniquePovKey] >= m_maxPovCount) {
        getDebugStream(state) << "PoV limit reached\n";
        return;
    }
    m_uniquePovMap[uniquePovKey]++;

    std::string prefix;
    if (recipeName.length()) {
        std::stringstream povFilenameSS;
        povFilenameSS << "recipe-" << recipeName;
        prefix = povFilenameSS.str();
    } else if (isCrash) {
        prefix = "crash";
    }

    std::vector<std::string> filePaths;
    if (!m_povGenerator->generatePoV(state, opt, prefix, filePaths)) {
        getWarningsStream(state) << "Failed to generate PoV\n";
        return;
    }

    onPovReady.emit(state, opt, recipeName, filePaths, isCrash ? CRASH : POV);
}

void PovGenerationPolicy::onSegFault(S2EExecutionState *state, uint64_t pid, uint64_t pc) {
    if (!m_process->isTracked(state, pid)) {
        std::stringstream ss;
        m_decreeMonitor->dumpUserspaceMemory(state, ss);
        getWarningsStream(state) << ss.str();

        state->disassemble(getWarningsStream(state) << "\n", pc, 64);

        s2e_assert(state, false, "Untracked pid=" << hexval(pid) << " segfaulted");
    }

    // TODO: might not be needed once we can figure out the real instruction of the crash
    if (m_crashCount > m_maxCrashCount) {
        getDebugStream(state) << "Reached max crash count limit\n";
        return;
    }

    ++m_crashCount;

    // XXX: it's more useful to report the address of the last instructions
    PovOptions opts;
    opts.m_faultAddress = pc;
    onPovReadyHandler(state, opts, "", true);
}

} // namespace plugins
} // namespace s2e
